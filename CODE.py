#!/usr/bin/env python
# coding: utf-8

# <hr style = "border-top: 25px solid #000000; margin-bottom: 7px;">
# 
# <span style = "font-family: Microsoft Sans Serif; color: #151515; text-shadow: 0 0 0px black; font-size: 29px; line-height: 1; font-weight: bold;"> Mathematical Modelling of Online Product Offerings via VADER Lexicon-Based Natural Language Processing and ARIMA Time-Series Analysis </span>
# <div style = "display: flex; align-items: center; line-height: 1">
#     <p style = "margin: 0;"> <strong> by </strong> </p>
#     <strong style = "margin-left: 5px;"> <span style = "color: #151515; font-size: large; font-family: Franklin Gothic Heavy;"> NORIE NEIL ACOSTA </span> </strong>
# 
# <a href = "mailto:ann1577@dlsud.edu.ph" title = "E-mail: ann1577@dlsud.edu.ph" style = "margin-left: 10px;">
#     <img src = "data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAAJkAAACYCAYAAAD3AEsfAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAALiMAAC4jAXilP3YAAA9oSURBVHhe7Z13cJRFGIfzp//hDJDEGhQL9ujoiKIRO3bsoKPGXhg1FgTHhgVRR43jKFhBQQcVFRtinVhQQEVwdIwdO2KLPfZ1n3UPkmMJt7e7X+4u7zvzTCbJ3fftffu7Le/77m5VVlZTU9Ovd+/eg4XSgPqwVVNeVldXt1J1dfXQPn36TOrbt2+LRQklj6kr6k0zjHq0VVoa1qtXr5UpmC7kVP2zvUPBhTLF1uNUTSP1a6u6e0wXpkmzqGMBhYqjjXrOvHWzXeJCR4GECoX61gyzEkhnNJ36hjLO6sFooc3WP2utJOKanpEMkNZLAKuDeiuNOKYvOETTlruJIGihtTNsshIJMy7kuokgWBqtVIozfYF6FJt3UUFYAvrAuWsl42f6ArUyBhMKpM07goBPRAuMWYTrgoLgotXLcavfMDrvAoJQCM1WQl2bfiHdpIzDBG+sblbsQ9Mvau74RkHwQQttupWS26zDVVoxIZTlO2q1wCY43iAIvky1klrWtMgko0KIQZszawOHmuPFglAUTget/ocM+IVoMPSy0lpq+o/i3ReigZ6stP43myfmfLEgFEunCACuC9eLBCEEdGUlJoN+IQ2dBv/6D435LxCECCzNNdO/SEBcSMFoKzEjsjF5/xSEGIyxEhORCckQkQnJEZEJyRGRCckRkQnJSSuympoatd5666k99thDnX/++eree+9Vc+fOVR999JFavHix+vbbb9U333yzXL7++mv13Xffqfb2dvXvv/+qnmJ81l9//dX5THz56quv1Mcff6zeeecdw+uvv65mzJihrrzySnXAAQeo9ddfX9XW1jrrLxLpRNavXz911FFHqbvvvlu98sor6t1331VffvmlamtrU7/99pv6448/Cuaff/6xj7/n2N9//+18FsXA8/7ll18MP/74o/nyfvjhh2revHlq6tSp6phjjlFrr722sx4jkEZk2267rbrkkkvUyy+/rP7880/72MRK0RDznDlz1OWXX6622247Z30GEldkdI877LCDuvnmm003J1Y+Rg9z2223qZ122il29xlXZIMGDVK33HKL+vnnn23RxcrJ6E7v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" alt = "E-mail" style = "width: 25px; height: 25px; margin-right: 5px;"> </a>
#     <a href = "tel:09673581501" title = "Phone: 09673581501"> <img src = "data:image/png;base64, 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" alt = "Phone" style = "width: 25px; height: 25px; margin-right: 5px;"> </a>
#     <a href = "https://www.linkedin.com/in/norzeelein" title = "LinkedIn: https://www.linkedin.com/in/norzeelein"> <img src = "data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAAJkAAACYCAYAAAD3AEsfAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAALiMAAC4jAXilP3YAAA30SURBVHhe7Z15bBVVG8b50/8wqbZ1BVeqslTcMC5B3OoKQkyqoNYQI4hRYolCg4BiA2qUREFihFSMUq0oymIV1OuG2KqAccGqWDcoolBXEBXf7zyH0w+4nIG5974zd+h9nuSXC7czc6YzT8+cOec97+kSl4qKisoM/UkyOPDAA0vdrdm31LVr1/0POOCASvML1BtS5t/LzaeQ5GLu0RbzmQLm3zOLi4sHuduZHJmTKzVUmROcj5MmnYJ2cz/rDJXdunXbz93q+IXCzclMwgntdHKkk2GM1mY+q9xtj0+mSh3hCveeGOl8mPu90nxWOAtEp5KSku6uMO+JkM6Puf/z0fZ2ltCVqb36mUL4aCS2VkOF46yhI3NgNOzxFuItlBQk7ah4nEVykzHXaE8BhHR0f+TWTsMBdj4oIR7ai4qKypxlMhN2xAHSDkjIbpgarTXjlwHXc9/qOyAhAaQy6rg1BpvpOQghewTtd2ehPctsXJ6+MyFhMCZrC1WbmQ05BklyYZqzkl8uBMS3IyGhMJUUujWCw4jMBo3pOxGSKcZHU5yldpV7o2SvPtFgtbPVrjI/qErbkJCs8Y5tssFPlBnrrLVdeO3ko5Iok3L22i7zBfvGiDbtzl7bZb7gQDhRZ5eOWfMFG/1EnV0a/+YLTAjxbkhItqBz31mMA+IkGoyvKp3FrMnqfBsRkiM7ptLl22R9+/aVYcOGydixY+Xee++VBx98UKZMmSK33XabDBo0SI466ijvfiTx5NdkZWVlcuGFF8oNN9wgd911lzz22GMyb948aWxslCVLlshLL70kzzzzjEyfPt2ab+jQoXLmmWfKIYcc4j0eSST5MdnBBx8s/fr1k5qaGnnzzTdlw4YN8vvvv8vmzZvlr7/+kq1bt/6fLVu2yJ9//ml//t1331nTwWys2fYZ4jcZaqFrrrlGnn32Wfnmm2/kn3/+kUz022+/yUcffST333+/nHzyyd4ySKKI12RHH320VFVVyeuvvy5///23s012Wr9+vX2MnnLKKd6ySGKIz2SlpaUyZMgQeeONN3I2WIc2bdoktbW1cswxx3jLJIkgPpPh0TZjxgzbxtIUHp0jR46U4uJib7kk78RnsltuuUVaWlqcNfSEWnHu3Lly/PHHe8sleScekx122GFSV1cn27Ztc9bQ1fvvv28fxezaSCTxmAzdFejzikqtra0yceJE6dGjh7d8klfiMdmVV14pb731lrOEvjZu3CizZs2S8vJyb/kkr8RjshEjRkhTU5OzhL7Qifvcc8+xOyOZxGOyUaNGSXNzs7OEvjBKsGDBAjnttNO85ZO8Eo/J0MO/bNkyZwl9YRSgvr5eTjrpJG/5JK/EY7IBAwbI0qVLnSX0tW7dOpk2bZr07NnTWz7JK/GYDMNJDQ0NzhL6+uyzz+TGG29EPLm3fJJX4jEZQCgPoi209d9//9nukTPOOMNbLsk78ZkMcWPz58931tDTDz/8IHfffTc7YpNLfCY7/PDD7RjjV1995eyRu/7991954okn5PTTT/eWSRJBfCYDJ554oo2a+PLLL51NshcCGRFBe9lll3nLIokhXpOBXr16yT333COffPJJVhEZqL0Q4vP8889bgyGEyFcOSQzxmwyccMIJct1119noCbSpwgqmXL58uR2nRKw/wrh9xyeJIj8mA6iBzj33XKmurpZHH31UFi9ebKMpVq9eLWvWrLF8/vnnsmLFCnn11Vflqaeeso9azGjiQPg+Rf5MtjPoR7vgggvsrKXbb79dJkyYYMEMJbwsYEpcnz59vPuSxJMMk4GSkhI59NBDbYfqEUccYenevbuNRTvooIO8+5B9guSYjHRaaDISOTQZiRyajEQOTUYihybLJxjUxwjIWWedJZdeeqlcffXVMnz4cLnpppvsFMLRo0fLrbfeKjfffLMNZULw5+DBg+X888+3UcDoL9wH5pvGZzJ0T2BuJKJXMdEXn7nQcQxMHjnyyCO9ZfpAdwj65TCOijkB6cfNBpwLUl8dd9xxe+1uQSc0umawPRLHID0WhsjQ6YzgSwyZ/fLLL/Lrr7/aiF+A/+P7n376yQYYYBY+phjecccdMnDgQGtUdP2gG8hXZp6Jz2Rnn3223HfffZJKpeTtt9+2n7mA2U/ICIRgSOTXCHuBjz32WNvpi4knOA/cMN/xw4L9cS4vv/yyTJ48eY/Ruai5LrnkEpss5pVXXpGPP/7YDqv98ccfbuAsnDChGab7+uuvrTlffPFFWzZquAQaLT6ToZpHohVt4WIjnizsQHnv3r1tkr1Mb2wYIXjSN5kFj7TzzjvPjrlimyiCN5FWC2bDSElFRUWSxnXjMxkiJjA+qa3vv/9e7rzzztAmwyMbN7utrc0dQUcYvEcCv/Rpeag5r7rqKptXDY+9qIXHLIJDr7/++qSkbojXZIsWLbLh0prCX/D48eNDmwyN5XHjxmUU/RFGiG9DzrWdTQaDIdHfhx9+aH8elzAPFYEGU6dOTcKE58IzGW48GsyoATXVYbKOxHxojKOdhEiSfAnXBhEuCItKvw4xUpgmQ3SHtslQezz99NO24Y/aEo9knFu+hcfn7Nmz8znRhibTEl4kEISJm4k+rSjSZGUrdIMgNxxqV981iZjCMxmyMiJmTbuWwVsuUiXgXBYuXKj+e+Yq/L55ykpZmCZDNK62yfDmiH6vVatWWcMlUTg/RBajM9h3bSKi8EyG3n4sQKFtMiR9iaLvTVNoN2J0AWkjfNcmImgyLSXt8Rgk5HIbM2ZM6OulAE1WiHrhhRfsnArf9YkAmqwQhYF49OHFNM5JkxWqMPSE+a8xhArRZPlUPttxiN5AqBFmg/mukyI0WZxCBzBCg5588kl5+OGHbegTeOSRR2zo0QcffGA7TuMQAgQeeOCBOAbRabKohdwdCDREGA5ytCH6FaMCWIYRgYbos8JQFBriGCl46KGHbJxb1H1t6HJBwhqkv/ddJ0VosiiFG/nee+/ZEQZE4iJoMaixjbYRomoRQXzxxRfLnDlz5Mcff3RHikbIUIm8cb7zUYQmi0pYnxPDS6i5Mh3KgRGRc23mzJmRGg3hThgBiPgtkyaLQuhZR3j1FVdcEfq8fOCxivab1qp66cKcAYQ9Rbz+AU0WhfCIzGTewZ6orKy0udwyXXw2jNDuQxvw2muv9ZatBE2mrfb2dtvAR9vKV36moC2H9PGodbSFN1mEJ+H6+cpWgibTFBr6eExedNFF3rKzARNCsDZVFBG2GNDHxBasgOwrWwmaTFOobfAmicBIX9nZgjYT+te0rx3ajuguwWouvnKVoMk09cUXX9iZ4L5ycwF9ao8//rh6KBFqXkxywSwyX7lK0GSaQj5bpBzwlZsLmCGPuaXffvutK0lHW7dutS8VqCV95SpBk2kJb3/oQY9iTQGsgYB8GFhvXVMwGabOvfPOO95ylaDJtITJvYg6PfXUU73l5gJGCpBsBTWlpmAyvFC8++673nKVoMm05Jvcq0XHGyZyf2iKJgupQjAZxjSRvee1115zpemIJgupQjEZrh/WM9AUTRZShWKyyy+/nCbbGzRZ9tBkIaHJsocmCwlNlj00WUiSYjIEEGJya1Spo2iy3Sg8k0Wdn4wm243CNFkUqaNoskBoMi3RZIHQZFqiyQKhybREkwVCk2mJJguEJtMSTRYITaYlmiwQmkxLNFkgNJmWaLJAaDIt0WSB0GRaoskCKTyTYeFTrCoXxwJeWtBkIUmKyZBwDrkqkJxXUzRZIDSZlmiyQGgyLdFkgdBkWqLJAqHJtESTBUKTaYkmC4Qm0xJNFghNpiWaLBCaTEs0WSCFaTIklKPJaLLQysZkWIaPJqPJQitbk2EBK03RZIHEazIkwNUWoimyMdn69evdEXSETNLz5s2L1GTa+cmw0klLS4vN4OgrV4n4TIaLhJyq2lq7dq1MmDAhI5PV1taqL76ATNJRpfOEyZAEL5VKudJ0tG3bNruCXVNTk7dcJeIzWUVFhV39YsOGDXaxddzkXPj5558tq1atkurq6tAmw/qONTU18umnn9plX3zHzgScA34fPLbr6uqkb9++3nJzASbDAhQwMc5Z6/qhXYolevDH7ytXifhM1r9/f7uI57Jly+zioWgH5AL++lDNY9H24cOHh17HqEePHjJy5EjbPly5cqX32JmAc2hubra1zNSpU6V3797ecnMBf0DnnHOOXTkE1w7l+c4lE3D9kIO2oaFBZs+e7S1XifhMRgoWmoxEzg6Tmf9MS/shITlTXFw8yFnMmmxs+gaE5IoxWT9nMWuyqvQNCMkV80LW3VmsS5eioqL+vo0IyQVnr+0yJivzbURItpiXyTZnr+3q1q3bfuYH7ekbEpItxmSNzl47xG4MosyO7osOmS8r0jYiJBdKnbV2CI9MU5tt8WxMSEYYHy13ttpdZoP69B0IyRRjstHOUrvLbFCevgMhmWAM1oanorOUX2ZDDjGRrNljLdYhs2Ep22YkS1bvtRbrkNmYtRnJmF0GxPcm96a53HcgQnwYv8x09gkvsyMem63pByPEQyr0YzJdZudyts/InkBF1LVr1/2dZbKTOVAFjUZ8GF+0IbjCWSU3IfgMB/QVRAoT44eVu8SLaQgHxIF9BZLCwvhgftZtsL0JBzaFcOipQDHmQrNpkrNDtDIFYfgp1VE4KQjq1R+PYWQKxksBH6GdG1Qm5e6W5084CcMkGq7TkDL3cnReaq4wwomZt9ER5kRhuik4YZJczD1qNJ+TgPl3Zc59XhQVv7p0+R+eIetW6psmcAAAAABJRU5ErkJggg==" alt = "LinkedIn" style = "width: 25px; height: 25px; margin-right: 5px;"> </a>
#     <a href = "https://github.com/norzeelein" title = "GitHub: https://github.com/norzeelein"> <img src = "data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAAJgAAACYCAYAAAAYwiAhAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAALiMAAC4jAXilP3YAABf8SURBVHhe7Z1nlBRFF4b9+f3Dc0TBCGZMiAKKAUQwYELEBJhQQFFB1wyKCibAhGIAVMS8BgQDgiiIGRB1zZgxgnnNmOvrp+g5uwx3d7unb/X0zNQ95z2Eme3qrX771q2barU0pFmzZquvscYaXT2ygTXXXLNd+GhKS7jxAOMCzAtRG8B4ZBqLA8xr3rz5rLXWWmtw8PeW4ePMhvBGBDc3IcCSejftUcIInmVNgKoWLVq0Dh9z+hISa750gx7lg+AZTwn+TE+rBcRqEww6Pf9GPMoXwfNeHmA0tnRIAzcSDDYyf3CPikItK1dIBz1p1arV/4KLV+cN5lGhYDMQUiO5BBdsGajHmvxBPCobAScmhBQpXNhFBBfyu0MPEQE3podUiS8si15zeTSFgCOjQ8rEE9gpXdDDIx8BV/qEtIkmsFK6kIeHhIAvywPDv1NIn8Yl+AHCPeKFPDwaQkCyGsyqkEYNi18aPQpFwJ2qkEayBGqul/SDHh5REBBsWaNaDDUn/aCHRwyMDOm0sgQf9Mj7YkWhRYsWZp111jHrrbee2WCDDUzr1q3NRhttZDbZZBOz6aabms0228wi93f+5LONN97YbLjhhiZ4c836669v1l13XdOyZUtxjApBrajFAu1F1Fz6gbIGJOrUqZM58MADzaBBg8w555xjLrvsMnPdddeZ2267zdx///3m4YcfNrNmzTJPPvmkxeOPP24effRR8+CDD5q77rrLTJw40VxxxRXmggsuMKeccorp16+f6d69u9l6660rlWw9QlrVCeun8MWyAlqmc+fO5vDDDzenn366ufzyy82tt95qpk6daubOnWteeeUV895775nPP//cfPfdd+a3334z//zzj2lM/vjjD/Pjjz+aZcuWmY8//ti8+eab5vnnnzePPfaYufvuuy1RId7AgQPNvvvua9q2bSveWzkh4NLKYaQwjVb8cilj7bXXtg+0W7dupm/fvmb48OFWKz377LPmiy++CCniXn799VdLvEceecRceeWVZvDgwWb//fc3O+20k11ipXsvZQQEWxJSa4XAOOmLpQhsKewolqfevXtbLfX0009b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" alt = "GitHub" style = "width: 25px; height: 25px; margin-right: 5px;"> </a>
#     <a href = "https://www.facebook.com/norzeelein" title = "Facebook: https://www.facebook.com/norzeelein"> <img src = "data:image/png;base64, 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" alt = "Facebook" style = "width: 25px; height: 25px; margin-right: 5px;"> </a>
#     <a href = "https://www.instagram.com/norzeelein" title = "Instagram: https://www.instagram.com/norzeelein"> <img src = "data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAAJgAAACYCAYAAAAYwiAhAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAALiMAAC4jAXilP3YAABYOSURBVHhe7Z1nkFRFF4b96T+sQtk1ghlFZc1gQFBRTIh5FcOKqJgBE1JmVFBUxARGTIABRUHFjFgKZsyoqJgRE2bM/fXT3PmEoWfn3NB3htlzqt5aZWd77sx9b/fp94ReJg9bYYUV6lu3bt1VUTVoH92apcsskXosv/zyo+zPqcD+9wL70yiqF/YezbQ/uVcT7c+mVq1aLRfdzspb27Ztl23Tpk0ve3Fj7MXNL1y0YqnHVHtf+9mf9dGtzt8sqRot5hRdmKKGYO8vK9CIXGc11nD7xkyr3otS1CRYnQaxYkU0yN4Y3L7J+EXeVNHCEK1YDRElsjM7aL3OWgrAsonfHVEjvdlBG+ygc4vfSNHiMSiiSHKzTO0EYz2DKxRgRESV+FZXV9dOZy5FOSBnRJSRGw69+lwKCVjhUBYi6sjM/hGqrndAhcKD+ax4EX2aN0uuRs8ACkWzsLyZElGotEVLo/pdikQoK19YcvX3/aFCIYHlz8yISkuafQFiqs5eirRoiii1uNlfDCp6oUKRBLMiSi1udvaa4XmxQhEbSyQ02n+sL36RQpECi4eR7D80Fb1AoUiDqRG1FppdHqd4XlRxrLLKKqZr166mb9++5rzzzjOjR48299xzj3nkkUfM008/bZ599tmax9SpU81DDz1k7rzzTnPNNdeYwYMHm0MOOcR06tTJ+51VCxZLUrQEq5rM1PXWW8/07NnTHH/88eaSSy4xt99+u3niiSfMa6+9Zj755BPz/fffmwULFpi//vrL/Pvvv6aWjc/H5/zll1/MN998Yz788EPz8ssvmylTppibbrrJDBkyxBx11FFmp512Mquvvrr3+6wUFgsf+V6QJ+rr602HDh3MbrvtZs455xz31H733XfR16zWnH3++efm/vvvNwMGDDDdunUz66yzjvc7zht20moskKuiDv6KK65oevTo4ab/N99803z99dfmjz/+iL4+NYn99ttv5ssvvzTTp083559/vtlqq62833WesATrXyBYQ/Ev80Lnzp3djIU/xRKglt4+/vhjM3nyZHPCCSe4VcH3vecBS7ChBYL1KP5laLRr187svffe5sYbb3RTvFr29s4775hhw4aZ7bff3q0SvvsQEpZgYwoEy1WiaNu2rTniiCOcn6VLYVhjQ3T33XebPffc06y88sre+xEKFSEYO51TTjnFvPLKK0qunOznn392u/DDDjvMe09CIXeCsbs5+eSTzRtvvBF9dLW8DKmDFaN3795mpZVW8t6frJErwdZYYw1zzDHHmLfffjv6yGp5W4FkvXr1ymW5zI1gbdq0ccrzM888Y/7555/o48Y3RMc///zT/P77725bjvjI9F/r4HPyeXEpIEkaYzwiIQizvnuVJXIhGOTaZpttzF133eXU96TGl4uSP2HCBDNy5Ehz1llnmRNPPNHNikcffbTp169fTYLPh4B67rnnmlGjRpkHH3zQvP/++6kiGD/88IOLkGy44Ybee5YVciEYftdll11m5s6dG328ePbRRx+ZSZMmmYsvvtgceeSRZueddzYdO3Y0q622mvf9ahW4GJtttpnZY489nL7FQ/b44487UTqJvfvuu6Z///6mrq7O+35ZIDjBWOf3339/92Hi2vz5881zzz3nntxqUKWrDehau+yyi7nqqqtc9IMlNK5BUFYXwnS+90iL4ATbdtttzS233OJ8iDj21VdfOQEWP2Gttdbyjq1YGL9dd9113UPMLI9/Fce++OILM3ToULPBBht4x0+L4AQ79thj3YeI4y8Q5mA51FlLDpa57t27u4c5ToIAGwb0SGZC37hpEZRgPBU33HBD9FFk9tlnn7knaqONNvKOqWge5M3deuut5qeffoq+0fLGawcNGhRkpQhKMEJB5C1JjSePbAolVzrsuOOObrmU7tiRfUhmZPPgGy8NghEMaQKyxJElHnjgAedw+sZTyIHzv++++7qlT2qk+QwcONA7XhoEIxgZqWRcSgz/7L333nPZq76xFPGBhIPOhf8rMe7BlVdeaVZddVXveEkRjGC77767ef7556PLb94QUJntNt98c+9YivhgBWGpRJSVGur+dttt5x0vKYIRjIC2NOaIJHH44Ye7L8U3VksFxS7kzJF9wswSV6vi9RdeeKHzsSQ2bdo0d998YyVFMIIh/n366afRpZc2YooEX3fYYQfvOC0RSA7MJKeffrq59tpr3U4csZkAddwlrKmpycyaNUsU/0WsRXv0jZMUwQhGvPDbb7+NLr20kSLN2r/xxht7x2lpYLZiNuf7wy/98ccfza+//uoqqR577DFzxhlnxHIl0MZY+niQyxkTAjljvnGSIhjByJqQqMqUYJ100klmzTXX9I7TksCSSELgiy++GH07Sxo6IfULEFHiUhCzxdknuF3OkIlIsfaNkxTBCEbWgyRb9a233jL77bdfRfLFqw1bbrml23mXS8fBV0KGkORzkZqOXyVZTZgp582b5x0nKYIRjHSSv//+O7r00oZWQ0GCb4yWBB6wAw88UOS3QgJmJUntI/4cgjd/U84gNrqlb5ykCEYw4omS+OMLL7xQteXvhE423XRT53BTs0nRxD777ONmD6qhqDwndQhxuKGhwc0WvnEk4G8ROiVEwJ+ihYA0l4sUaUmqFPeLzYBvjKQIRjDJk4ihlW2xxRbeMfIGN5n4KUF2SMTScsUVV5hx48a5pQu/Ev+I8BfXzVJF7SGxP4LzBPYJt+CEIzTjU/nexwfkCHKzJLldzDJckzQD4qCDDoqVi+cbIymUYBboRVzDcccd53pgMKuy+UAFx/Fls8KsgZ7Esl8APiY3m50eu2EccFwDiIi8QIq4tOiVazjggAPcbrGcQZbhw4eL2wMowSpEMJxkZhzESOKgr7/+eux8qlKGUw1RmWmQFshy8F3DosDJf/jhh8sKo3TbiVO0oQTLmWDcGBqEnHrqqS6LQLKFT2NUrY8dO9bl10Mi3zUBlug+ffq4FgqlduCzZ892qTVx0sWVYDkSDF8Hp3fixImu4lmy083CmJX4TlDl2TCUUuQhPyQr5NpDfpZgrvWll15yD8X666/v/dtSUILlRDB2XTSwQ6OLm8KdlUEUfDSKNiC77zoRUZlhkReonKJTDpkmEDNJWyYlWA4EozaA+KjEic7DqGyHPOWSK4lwkHOfpvJHCRaQYNwYZoMxY8bESiPOw/iO2GCEjsMqwQISrEuXLk6nSlLSlYeRqnTRRRcFTRNXggUiGDMDTnW1t+HkuyKATWGt73OkhRIsAMHat2/vZoakVc+LGpoWAurMmTOdtsU1s6PDj5ozZ04mMgeFyQi9Um0rDpRgGRMMCYB+DsRDkxjSBco8N50cLNK5EUvp5IzEQVAalZ73IBHw5ptvdjtD1H92iUmN74IGyFm3VlKCZUywvfbay8UOk3TxIfRDvBHnG5WfYDe6E4FvhFDii8wyhXRmZANignyGxsZGFyKCmEk64LAJoS151pVVSrAMCca2ngB1kmWLJY8YHxkTSbvO8FmY3fD9kkgilI+RgBk3/745KMEyIhg5VQSM8Y/iGKIrdQHc2CRCpg9kVCCQEt+MO5Pee++9bvfrGzcJlGAZEYylCr0rzuxFlgSlXQSP46TXSMBsit9GUmWcJbOQFp2VL6YEy4hgOMhxe79CLhIJQ/UsJexDT7M4LRSY8biurARYJVgGBCOcQuhFknuOMaMQk6SCJ00YRgI2A2effbZrpCc1ii8IeqfJki1ACZYBwUhdZuco7YWBM82JZWSe+sbLGqTpsMOUXh9yBzvKLGYxJVgGBGMmkp4WwhLEUYB51gJQYkaTOKqoJLUKvAa5JIuCGCVYSoKxezzzzDPFjvQHH3zgqqazbvRRDsQbKTKWnsfEA4O25hsrDpRgKQnG7pHlR2oUarBkhfa9ioFAy4aCWUxi9Kg97bTTSuaNSaEES0kw/C8yVCVGKjKzSN7kKoCHgeVZkklLfUAWXYeUYCkIhm9z8MEHu1igxIhPck6Sb6w8wGx09dVXizI80OiyODBBCZaCYMxEpBOjmJczHGcqcghY+8bKA4i5EFzS1p08/qeeesoV+frGkkIJloJgxOyosiGToZyxLHHscKiOyhLgh9HgZMaMGdFVlTauF4GWGdo3lhRKsJQEI6wikSjYZd5xxx2Zd/GLA3a8zEhPPvlkdFWljRmXDQESjG8sKZRgKQjGDSOoLPkCIRh95LfeemvvWHmAB4I0oEcffTS6qtIGwVhK+/bt6x1LCiVYSoJRioYyX84KBKtkJ2sIhlRBImM5g2CEjChf840lhRIs5RJJDFKSewXBOPGN5ri+sfIAQXXEU8mul4gDadqHHnqodywplGApCUYXHMmujBvGzJF2V5YGOPmkWkOccsYDwWFg5Lj5xpJCCZaCYMgUpMNIkwxJ56FHhG+sPEBPiSFDhricr3KGKEwzFFrC+8aSQgmWgmCAGQl1XGJkKbAp8I2TB8jtHz9+vKhOk9dQ09klZXarEiwlwTp37mxuu+22aMTyxmsrcUQgUQc2GBINDKPpCaV3cZudFEMJlpJghF/oMCi16dOnu9SZEDWIzYEUavL+qaWUGDWdpFzjZ/rGk0IJlpJggLO7pb0nyFK4/vrrMyvwkIKlLk5SJH3ySQP3jRUHSrAMCEapGTszdl4S45gb2qfnNYvRFoDeXtKUbgLdNMdj+feNFwdKsAwIxhjXXXeduKKIVBic7TyOsMH3ohqc8JC0hA1djxAYLRB8Y8aBEiwDgjETEbOLU+wKGek3L+3WnBSEpqQ7x4Khf5Hnltb/AkqwDAgGWE44a0d6uhhGFgayRdqdWimwa+SAqThNWCgE5m+y6rajBMuIYNQg0qQkbtMTysmQA7pYJzyrTFcEVQRSGqOwqYhjFHvQfsA3bhIowTIiGCDXntJ7qa9TMDJMSeVBtEVOIIjuG78cWKophSMDAvFXcl7TosbrL7300kx3uEqwDAmGz4LWJIlNFhs+GQl+pDRDtLhFrzjkZD5wmANnNErliIKxtON7ZR0rVYJlSDBAseqIESMSt80knESqMpVKVPWwXNHhGWeddk6MTyEGjYXJ7YJUVG6TCkRMNO6sVTDikxwnk7U+pwTLmGCAlBxEzaQ3u2CQDZ+IqiUcbyqSIC+zHIRCq+Kk2LQ9YBGJGT9p26jmoAQLQDCWSg60Iu5H4l4aIzceonKeIjs8NDR+Qir+PYvx77vvvmCp3EqwAAQDVG6TmkP7pGo2ZlraR0lOsE0CJVggggGkC07VoJNOtRmzH0fGMNMm3bVKoAQLSDAAyZjJcMDj7uxCGak4+G/sGEP1JitACRaYYADJgVx4MkTTOv5pDeGVDQIV23kE25VgORAM4PgjN3BmEakweRubAXaktD7Ps7JJCZYTwQqgjRKpM8xmcboOJjVmTMrPOGcbhZ8l23ddoaAEy5lggKWJs7kpeaNfBcFoZIi0kkPBkB7QtjiWmV0ip3h07NixIl19lGAVIFgB9HaliyAHuhOYRjRNuxHAx+JzjRw50jQ1NbnlMNQ5RBK0eIKl7X+VBZAJIAI5ZcxqhIkQP5ndIB0ZGpyMhrIPCI5z00j3QQLhGGSKeiEV3RO5qYSVfO+VN3QGq+AMVgr4SSjrdLYheE52KcmJEIhNAqeJUGhC606WP9Kv6fmaVwp2HNQkwXCeJSkzaFN57qjiAGUdjYqeXuR3Ub0E8Qrg//l3SBVSKE0LWg8w+5Yz7hcZHb4xkiIYwUhXkWSWsrzsuuuuwcIkLR08ILQqkGTUsttFAPaNkxTBCIbeI8kwIG8Lvyfvjs8tBaT+4FPiN5YzyIWv6RsnKYIRjK25JFWYxnG0XwqVE9/SgRRDDSjZH+UMP40DV33jJEUwghEKkfTsQitCgKxkU7haBvWitIqSuCuc6jthwgTvOEkRjGB0kJk9e3Z06aUNQRKVm6ZsvnEU6TBw4EAnqUgEZDZcw4YN846TFMEIRqNbSQ8sjOmbaqBKipG1CIpPOO9Iarg1aXuRFSMYwahRRHyUGOX+9CzlKGTfWIr4QDZh9/jqq69G33J546zNrH3hYARDO6KaWWqkIV9++eWZHF+nWFj4QiSCHhcSIw5LAXLWclEwggG2x9IT0DBadpMYWM2i5dIA4qsXXHCBWL3HD8adwa3xjZcGQQlGQt2kSZOij1HeUJKJ/eXZ9abWQGO9AQMGuB2h1JjlOBMpRMguKMEgCRpXnAxSMhlo1FuJBnFLO3AvqD+gyCVO2hFxY2o/Q6QSBSUYIOecauU4DUmIAKDd4KSqTyYDHYIIyNPkWNojDUOH5MCtLPqQ+RCcYJTTk74iPYRzUeNJpCkJTUQ0lOQH/ha9x0aNGpUoO5dGfMxeoR7k4AQDpLFQQZOk2AKNDH0Gv4Jq7U022cTF11ri8skOjweNhxZ/iQePWYvwTtxmLxizF3lvIRsi50IwyEBmp7SXfbFBTGZANB1CUMyICIJkopKs2NDQUNNAcuAhpSEdqTcUjRDSIWOFIDa7wCTGBiz0yXO5EAyg0qOzSBMRSxkBdEJQLJ/4aRSu0iaploEITftNdtjICWQ8pO2FQZYuB1iEXglyIxggss92OG5DNrVsjTbqgwcPNh06dPDepyyRK8FAt27dnMIvyU9Sy95oEUXEJEQXHx9yJxjFr5Bs3Lhx4o7QatkYURXIhV/nuzchkDvBCsBBHz16dKxQklpyQ47AB867gqtiBAPsjIYOHery8pNIGGrljVVi2rRpLi8Mzcx3H0Li/wRr3bp1V98LQmPttdc2ffr0cTslcsKTbrnVFjce2Hnz5pmxY8e6ZE6yW3zff2gsSrD2vhfkAVRk/DJEQ+ok44Q61JY0Up8Qp6nnpOt26PZQzcESbKgjWKtWrZbzvSBPMJv17t3bDB8+3H1BkkM71RYaMz8dg8gBQ4jt2bNnVUQ7LMH6O4Jh9n8W+F6UN/hiUJiJQ06ePNkp+Hx5bAg4TIonlBQTZrqsmpVUuxWKYsk2wZUgssEDSNkfoSLaFpB2Xm1FzJZTjRG9HMHm+F5UCRB3o2oax7R79+4uDQWRlpgmajZfLl80vkatk4zPx+dEO0QkLXS9RnKgHRSkIp5YKT+rOeDbR/RyBBvje5FCkQSsiNa/XjailyNYo++FCkUSWD5Niai10HD0YZ3vxQpFXFg3p19Erf8M1vlerFAkQH1Eq/8M1nleqFDEgp2oZkSUWtxwyuwv5/r+SKGQwk5UvSJKLWn80vdHCoUEdoKaGFGptNkXzfT9sUIhQENEo9Kms5giIcZHFCpv9sUjiv5YoSgJu+rNQeqK6CMz+0cqWygkmE9GTkQbuUVZFrOKBlMoitEjokx8q6ura8f05xlUoQBNEVWSmx2k3pJsRtHAipaN+c3qXXENEdYOOr7oTRQtENGKVl6OSGJ24EH2DTQo3kLBxi/2bjGu2TdiyRxV/OaK2oW93zMXSyDMw9ia2jee6LsgRW3A3t85Fv+lPlfC2GmSiWEvRHWz2gDS1Ah7TztFt7h6LEpcJDv2XBCRbqqiqkHUhnvVP5FgqqZWOVtmmf8BrK8UEnKEOnsAAAAASUVORK5CYII=" alt = "Instagram" style = "width: 25px; height: 25px; margin-right: 5px;"> </a>
#     <a href = "https://twitter.com/norzeelein" title = "Twitter: https://twitter.com/norzeelein"> <img src = "data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAAJkAAACYCAYAAAD3AEsfAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAALiMAAC4jAXilP3YAABYCSURBVHhe7Z1nkBVFF4b9+f3DKnTFuJgxY0LMIAbEhIqKmMAEBgQVBVR0DSViAgVFRUHFcs1rxowRVFTMmDFjxoy5v36aHmUvvX3PzE0zc/tUvbXUMrfv7Mw7p0+/55yeJaplDQ0NXdu3b98tIB1obGz8n7012bJlllmm41JLLTV06aWXnm4xR0MFpBf6fs3TP8390v8erX92trczPaafik76xJr0Cc7mpAOyD30v5+qfY/F49jbXxvBa+kSaFz25gPxBE25m1cnWrl27JfWXj9VfvqDwhALyC32/W5i1LA0qZzp4762/cH7hCQTUFZosHcpvmskE9K4vDag/NJd1dcpgmmBTHF8UUMfQnGCh18HSJLlZgk0r/IKAAKC5MZcFoKVLMtODTHQNHhAQAY+WeOrUHw4xWIAImistljZy0x/sWThQQIAPmmijLX2Km43DSDU4BwsI8ECWkgrTZEBSiKZNfWAHfWBQ8gMSA8He0slt+qCxhR8KCIgD7aRmWzotbuQkgxcLKBN6Wlq1Nk2wvo6DAwJiQ3NpoqVVa9P/EVJHAWWB5tJcS6v/DNlC/2eorggoGyi3t/RaaBSluQ4MCCgBrUuCtHsL2lhAWaE51Voz07+ggcB5cEBAEmhOzbT0Wmj6FyHoDygrNKdaB//6l7REOQ8OCEgKS6+Fpn8R+iMDKoH/KmdxbY4DAgJKQquq2UCygEqgaiQ75JBD1NChQ9W5556rxowZY35WC+edd575OWTIENWlSxfn+WUFXbt2VYMHD1ajR4/+9++SgGPPP/98dcwxx6gNNtgAkdQ5fiVQNZINGjRIXXHFFeq7775T2O+//141/PXXX+bnRx99ZC722muv7TzHtGPTTTdV48ePV3PnzlV//PHHv39XMfz555/mmn/yySfmAd9oo43ySbIOHTqoXXbZRT322GPm4tTC/vnnH/XKK6+oE088UXXs2NF5nmlF586djSf6+OOPzd8R1+bPn28Iuvnmm1eVYKCqMdnyyy+v+vfvr1577TX7p1ff8ABPPfWU2mOPPQzxXeeZNqy11lpq5MiRxoMlsR9++EHdcMMNarvttuOGO7+jkqgqycDKK6+szjjjjMQXrBz266+/qltvvVVttdVWznNME/C4xJJvvPGGPft49ssvv6h77rlH9erVSy277LLO76g0qk4yQExw+eWXqx9//NFeiuob333RRRepddZZx3mOacAKK6ygDjvsMPXss8/as45neO1HH31U9e3bt6ZeuyYkA7vuuqt5wghMa2V401NPPdVM465zrCWWW2451adPHzO1J4lhidtmzZqljjzyyJp5sAg1I9mKK66oDj74YPXqq6/ay1IbmzFjhjrggANSRzQewocffjjxQ/j222+r4447Tq222mrO8auJmpEMcAFOOeUUs2KKY6yUWI5/8cUX6quvvloM8+bN+1cqKWY///yz8ajdu3d3nmMtsMMOO6jbb7/9X+khrn344Ydq1KhRao011nCOX23UlGQAzYr47Pvvv7eXqLi99dZb6rrrrlNjx45Vl1566WK4+OKL1dVXX21WscQlxQxCjhs3Tm244YbOc6wmtthiC7MSTOrBePAuuOACteaaazrHrwVqTjKAF7n55pvF+g8kO/300412xNPKBV0U/A5Ve9iwYeLp+NNPPzXH13LaZEE0adIksRcuNBYzEyZMMNfFNX6tkAqS6ZNQ/fr1UzNnzhRNEXi9u+66S22zzTbO8SJAOLza119/bT/pNwLlgw46yDlWpYEXxQN9/vnn9mziGVLFtddeq7bcckvn+LVEKkgG8D7kNt977z172fzGU8uUiYLtGi8CAuRNN90kmn5Yxd17773Gs0J813iVACEDnjlubBoZcWVLS4vq0aOHc/xaIzUkA+uvv75JfRC8S4xp5eyzzy4a4O61115Ga/r777/tJ9s2vpsc68Ybb+wcq9xobGw00/Trr79uzyCe8fA88MADavfddzeyh+s7ao1UkQwQ+KLGSwiBsVTHA/rExpVWWkkdddRRJpaTGKsz8puVXp1xXkcccYR5AJKuJJ988kkjBaVR64uQOpIBPM/jjz9uL2Nxe/rpp9W+++7rFR0hDAlmpA+JvfDCC+rAAw90jlUOQIr99tvPkCTpSpJk/9FHH21Sda7vSAtSSTLcPqVB77zzjmjFSdB75513qm233dYbSxEUE8eRu5QYYxLTucYqBXhdpjfiv6QE49oMHz7cJM9d35EmpJJkgPjsnHPOUZ999pm9rH4jliIXiQzgGg9Q4oL3wEtKpicW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" alt = "Twitter" style = "width: 25px; height: 25px; margin-right: 5px;"> </a>
# </div>
# <hr style = "border: none; border-top: 5px solid #000000; margin-top: 5px 0;">

# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ IMPORTING PYTHON LIBRARIES 
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# The first part of the code serves as a foundational framework for a versatile data analysis and modeling pipeline of the study. It imports essential libraries and tools spanning multiple domains, including data manipulation, visualization, natural language processing, and time-series analysis. For data manipulation tasks, we incorporate <strong>NumPy</strong> and <strong>Pandas</strong> for efficient numerical operations and structured data handling, alongside the <strong>Counter</strong> class from the collections module for element occurrence counting. Visualization capabilities are enriched by <strong>seaborn</strong> and <strong>matplotlib</strong>, empowering the analysis to create visually appealing and informative plots and charts. The <strong>NLTK</strong> serves as a versatile toolkit for natural language processing tasks, augmented by additional tools such as the <strong>NRC Lexicon</strong> and <strong>SentimentIntensityAnalyzer</strong>, which are utilized specifically for analyzing sentiment within the textual data. Additionally, <strong>WordCloud</strong> enhances the visualization of word frequencies in text, contributing to a more comprehensive understanding of the linguistic patterns in the data. Furthermore, for time-series analysis, we incorporate <strong>pmdarima</strong> for automated model selection, along with <strong>statsmodels</strong> for implementing ARIMA models and associated functions for model evaluation.
#     </div>
# </details>

# In[1]:


# DATA MANIPULATION
import warnings
import numpy as np
import pandas as pd
from collections import Counter


# In[2]:


# DATA VISUALIZATION
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from matplotlib.collections import PolyCollection
from matplotlib import pyplot
from tqdm.notebook import tqdm
get_ipython().run_line_magic('matplotlib', 'inline')


# In[3]:


# NATURAL LANGUAGE PROCESSING
import nltk
from nrclex import NRCLex
from nltk.sentiment import SentimentIntensityAnalyzer
from wordcloud import WordCloud, STOPWORDS


# In[4]:


# TIME-SERIES ANALYSIS
from pmdarima import auto_arima
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_percentage_error
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from sklearn.model_selection import train_test_split


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ RENDERING PRODUCTS DATAFRAME 
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# For the following part, we create and display dataframes for three distinct product categories: <strong>Baby Pacifier</strong>, <strong>Hair Dryer</strong>, and <strong>Microwave Oven</strong>. Each dataframe is loaded from a corresponding CSV file using the <strong>pd.read_csv()</strong> function. After loading each dataframe, we adjust the index to start from 1 instead of the default 0. We then display the first few rows of each dataframe using the <strong>.head()</strong> method to provide an initial overview of the variables and structure of the datasets.
#     </div>
# </details>

# In[5]:


# BABY PACIFIER DATAFRAME
BabyPacifier = pd.read_csv("BabyPacifier.csv", encoding = "latin-1")
BabyPacifier.index = BabyPacifier.index + 1
BabyPacifier.head()


# In[6]:


# HAIR DRYER DATAFRAME
HairDryer = pd.read_csv("HairDryer.csv", encoding = "latin-1")
HairDryer.index = HairDryer.index + 1
HairDryer.head()


# In[7]:


# MICROWAVE OVEN DATAFRAME
MicrowaveOven = pd.read_csv("MicrowaveOven.csv", encoding = "latin-1")
MicrowaveOven.index = MicrowaveOven.index + 1
MicrowaveOven.head()


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ OVERALL PRODUCTS DATAFRAME 
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# We collate all the individual product dataframes (Baby Pacifier, Hair Dryer, and Microwave Oven) into a single comprehensive data frame named <strong>AllDataFrame</strong> using the <strong>pd.concat()</strong> function. This step combines all the data from different product categories into one unified data structure, facilitating a holistic analysis of the entire product dataset. Next, we compute descriptive statistics regarding the quantity of data available for each product category. This is achieved by grouping the combined dataframe <strong>DataSet</strong> and calculating the size of each group using the <strong>.groupby()</strong> and <strong>.size()</strong> methods. The resulting information is then converted into a dataframe named <strong>ProductCategoryDescriptivesDataFrame</strong>, which provides the total count of data entries for each product category.
#     </div>
# </details>   

# In[8]:


# COMBINATING ALL DATAFRAMES
AllDataFrame = [BabyPacifier, HairDryer, MicrowaveOven]
DataSet = pd.concat(AllDataFrame)
DataSet['REVIEW BODY'] = DataSet['REVIEW BODY'].fillna('')
display(DataSet)


# In[9]:


# PRODUCT CATEGORY DESCRIPTIVES
ProductCategoryDescriptives = DataSet.groupby("PRODUCT CATEGORY").size().to_frame("TOTAL")
ProductCategoryDescriptivesDataFrame = pd.DataFrame(ProductCategoryDescriptives)
ProductCategoryDescriptivesDataFrame.T


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ PRODUCTS STAR RATINGS
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# In this segment, we conduct an analysis of star ratings across various product categories. For each category, we filter the dataset accordingly and then group the data by both <strong>"PRODUCT CATEGORY"</strong> and <strong>"STAR RATING"</strong> columns to compute the count of each star rating category. This process yields separate dataframes for each product category, namely <strong>BabyDataFrame</strong>, <strong>BeautyDataFrame</strong>, and <strong>MajorAppliancesDataFrame</strong>, containing the counts of star ratings for Baby Pacifier, Hair Dryer, and Microwave Oven products, respectively. These analyses provide insights into the distribution of star ratings across different product categories, allowing for a better understanding of customer satisfaction levels and product performance within each category.
#     </div>
# </details>   

# In[10]:


# BABY PACIFIER STAR RATINGS
BabyPacifierDescriptives = DataSet[DataSet["PRODUCT CATEGORY"] == "Baby"]
BabyDescriptives = BabyPacifierDescriptives.groupby(["PRODUCT CATEGORY", "STAR RATING"]).size().to_frame("COUNT")
BabyDataFrame = pd.DataFrame(BabyDescriptives)
BabyDataFrame.T


# In[11]:


# HAIR DRYER STAR RATINGS
HairDryerDescriptives = DataSet[DataSet["PRODUCT CATEGORY"] == "Beauty"]
BeautyDescriptives = HairDryerDescriptives.groupby(["PRODUCT CATEGORY", "STAR RATING"]).size().to_frame("COUNT")
BeautyDataFrame = pd.DataFrame(BeautyDescriptives)
BeautyDataFrame.T


# In[12]:


# MICROWAVE OVEN STAR RATINGS
MicrowaveOvenDescriptives = DataSet[DataSet["PRODUCT CATEGORY"] == "Major Appliances"]
MajorAppliancesDescriptives = MicrowaveOvenDescriptives.groupby(["PRODUCT CATEGORY", "STAR RATING"]).size().to_frame("COUNT")
MajorAppliancesDataFrame = pd.DataFrame(MajorAppliancesDescriptives)
MajorAppliancesDataFrame.T


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ INTEGRATING COLORS AND PATCHES
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# In this section, we integrate color sets and patches to visually represent star ratings across different products. Each product category is associated with a distinct color set defined by hexadecimal color codes. For Baby Pacifier, color patches are created for each star rating level, ranging from one to five stars, with corresponding colors and label counts retrieved from the <strong>BabyDataFrame</strong>. Similarly, color patches are defined for Hair Dryer and Microwave Oven products, with colors and label counts retrieved from <strong>BeautyDataFrame</strong> and <strong>MajorAppliancesDataFrame</strong> respectively. These color patches serve to visually represent the distribution of star ratings for each product category, aiding in the interpretation and comparison of customer ratings across different product types.
#     </div>
# </details>   

# In[13]:


# COLOR SETS
OneStar = ["#BEABCF", "#73D3AA", "#F2D9A0"]
TwoStar = ["#A389BB", "#49C791", "#ECC670"]
ThreeStar = ["#8967A7", "#34A675", "#E5B03F"]
FourStar = ["#6D4F89", "#277D58", "#D39B1D"]
FiveStar = ["#412F51", "#133D2B", "#876313"]


# In[14]:


# BABY PACIFIER COLOR PATCHES
BP5 = mpatches.Patch(color = "#412F51", label = "★★★★★ : %s" % BabyDataFrame.COUNT[4])
BP4 = mpatches.Patch(color = "#6D4F89", label = "★★★★☆ : %s" % BabyDataFrame.COUNT[3])
BP3 = mpatches.Patch(color = "#8967A7", label = "★★★☆☆ : %s" % BabyDataFrame.COUNT[2])
BP2 = mpatches.Patch(color = "#A389BB", label = "★★☆☆☆ : %s" % BabyDataFrame.COUNT[1])
BP1 = mpatches.Patch(color = "#BEABCF", label = "★☆☆☆☆ : %s" % BabyDataFrame.COUNT[0])
BP0 = mpatches.Patch(color = "#FFFFFF")


# In[15]:


# HAIR DRYER COLOR PATCHES
HD5 = mpatches.Patch(color = "#133D2B", label = "★★★★★ : %s" % BeautyDataFrame.COUNT[4])
HD4 = mpatches.Patch(color = "#277D58", label = "★★★★☆ : %s" % BeautyDataFrame.COUNT[3])
HD3 = mpatches.Patch(color = "#34A675", label = "★★★☆☆ : %s" % BeautyDataFrame.COUNT[2])
HD2 = mpatches.Patch(color = "#49C791", label = "★★☆☆☆ : %s" % BeautyDataFrame.COUNT[1])
HD1 = mpatches.Patch(color = "#73D3AA", label = "★☆☆☆☆ : %s" % BeautyDataFrame.COUNT[0])


# In[16]:


# MICROWAVE OVEN COLOR PATCHES
MO5 = mpatches.Patch(color = "#876313", label = "★★★★★ : %s" % MajorAppliancesDataFrame.COUNT[4])
MO4 = mpatches.Patch(color = "#D39B1D", label = "★★★★☆ : %s" % MajorAppliancesDataFrame.COUNT[3])
MO3 = mpatches.Patch(color = "#E5B03F", label = "★★★☆☆ : %s" % MajorAppliancesDataFrame.COUNT[2])
MO2 = mpatches.Patch(color = "#ECC670", label = "★★☆☆☆ : %s" % MajorAppliancesDataFrame.COUNT[1])
MO1 = mpatches.Patch(color = "#F2D9A0", label = "★☆☆☆☆ : %s" % MajorAppliancesDataFrame.COUNT[0])


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ RENDERING BAR PLOT VISUALIZATION
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# We generate a stacked bar plot to visualize the distribution of star ratings across different products. First, we calculate the percentage distribution of each star rating category within each product category using numpy arrays and basic arithmetic operations. Then, we create a figure using <strong>matplotlib.pyplot</strong>, specifying the figure size and adding grid lines for better visualization. Next, we use the <strong>plt.bar()</strong> function to create stacked bars, with each bar representing a different star rating category. The bottom parameter is used to stack the bars on top of each other. Text annotations are added to display the percentage values and total counts for each bar using the <strong>plt.text()</strong> function. Additionally, labels and legends are customized to provide clear information about the data being visualized. The visualization effectively communicates the distribution of star ratings across different products, facilitating insights into customer satisfaction levels and product performance.
#     </div>
# </details>   

# In[17]:


# BAR PLOT CALCULATIONS
x = sorted(list(DataSet["PRODUCT CATEGORY"].unique()))
y1 = np.array([BabyDataFrame.COUNT[0], BeautyDataFrame.COUNT[0], MajorAppliancesDataFrame.COUNT[0]])
y2 = np.array([BabyDataFrame.COUNT[1], BeautyDataFrame.COUNT[1], MajorAppliancesDataFrame.COUNT[1]])
y3 = np.array([BabyDataFrame.COUNT[2], BeautyDataFrame.COUNT[2], MajorAppliancesDataFrame.COUNT[2]])
y4 = np.array([BabyDataFrame.COUNT[3], BeautyDataFrame.COUNT[3], MajorAppliancesDataFrame.COUNT[3]])
y5 = np.array([BabyDataFrame.COUNT[4], BeautyDataFrame.COUNT[4], MajorAppliancesDataFrame.COUNT[4]])
ArrayTotal = y1 + y2 + y3 + y4 + y5
y1 = (y1/ArrayTotal*100)
y2 = (y2/ArrayTotal*100)
y3 = (y3/ArrayTotal*100)
y4 = (y4/ArrayTotal*100)
y5 = (y5/ArrayTotal*100)


# In[18]:


# STAR RATING STACKED BAR PLOT VISUALIZATION
plt.figure(figsize = (10, 7))
plt.grid(color = "black", linestyle = "--", linewidth = 1, axis = "y", alpha = 0.3)
Grid = plt.gca()
Grid.set_axisbelow(True)
plt.bar(x, y1, color = OneStar)
plt.bar(x, y2, bottom = y1, color = TwoStar)
plt.bar(x, y3, bottom = y1 + y2, color = ThreeStar)
plt.bar(x, y4, bottom = y1 + y2 + y3, color = FourStar)
plt.bar(x, y5, bottom = y1 + y2 + y3 + y4, color = FiveStar)
for xpos, ypos, yval in zip(x, y1/2, y1):
    plt.text(xpos, ypos, "%.2f" % yval + "%", ha = "center", va = "center")
for xpos, ypos, yval in zip(x, y1 + y2/2, y2):
    plt.text(xpos, ypos, "%.2f" % yval + "%", ha = "center", va = "center")
for xpos, ypos, yval in zip(x, y1 + y2 + y3/2, y3):
    plt.text(xpos, ypos, "%.2f" % yval + "%", ha = "center", va = "center")
for xpos, ypos, yval in zip(x, y1 + y2 + y3 + y4/2, y4):
    plt.text(xpos, ypos, "%.2f" % yval + "%", ha = "center", va = "center")
for xpos, ypos, yval in zip(x, y1 + y2 + y3 + y4 + y5/2, y5):
    plt.text(xpos, ypos, "%.2f" % yval + "%", ha = "center", va = "center")
for xpos, ypos, yval in zip(x, y1 + y2 + y3 + y4 + y5, ArrayTotal):
    plt.text(xpos, ypos, "TOTAL = %d\n" % yval, ha = "center", va = "bottom")
Labels = ["Baby Pacifier", "Hair Dryer", "Microwave Oven"]
plt.xlabel("\nSUNSHINE COMPANY PRODUCTS")
plt.ylabel("PERCENTAGE BY STAR RATINGS\n")
plt.ylim(0, 110)
plt.yticks(np.arange(0, 110, 10))
plt.xticks(x, Labels)
plt.legend(handles = [BP5, BP4, BP3, BP2, BP1, BP0, HD5, HD4, HD3, HD2, HD1, BP0, MO5, MO4, MO3, MO2, MO1],
           bbox_to_anchor = (1.01, 0.5), title = "STAR RATING COUNTS:\n", loc = "center left")


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ RENDERING WORD CLOUD VISUALIZATION
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# We generate word clouds to visually represent the most frequent words used in customer reviews for three products. For each product category, the customer reviews are combined into a single string variable (<strong>BPCommentWords</strong> , <strong> HDCommentWords</strong>, and <strong> MOCommentWords</strong>). The text is preprocessed by converting it to lowercase and splitting it into tokens. Additionally, stop words and irrelevant terms are removed to enhance the quality of the word clouds. Word cloud objects are then created using the <strong> WordCloud</strong>  library, specifying parameters such as width, height, background color, stopwords, minimum font size, maximum number of words, and colormap. Finally, the word clouds are displayed using <strong> matplotlib.pyplot</strong> , with titles indicating the respective product names. This visualization technique offers insights into the recurring themes and sentiments expressed in customer reviews for each product category, aiding in understanding customer perceptions and preferences.
#     </div>
# </details>   

# In[19]:


# BABY PACIFIER REVIEWS WORDCLOUD VISUALIZATION
BPCommentWords = ""
BPStopwords = list(STOPWORDS) + ["will"]
BabyPacifier.rename(columns = {"REVIEW BODY": "REVIEWBODY"}, inplace = True)
for val in BabyPacifier.REVIEWBODY:
    val = str(val)
    tokens = val.split()
    for i in range(len(tokens)):
        tokens[i] = tokens[i].lower()
    BPCommentWords += " ".join(tokens) + " " 
BPWordCloud = WordCloud(width = 800, height = 600, background_color = "white", stopwords = BPStopwords, 
                        min_font_size = 10, max_words = 50, mask = None, colormap = "Purples",
                        random_state = 0, collocations = False).generate(BPCommentWords)                    
BabyPacifier.rename(columns = {"REVIEWBODY": "REVIEW BODY"}, inplace = True)
plt.figure(figsize = (8, 8), facecolor = None)
plt.imshow(BPWordCloud)
plt.axis("off")
plt.title("BABY PACIFIER\n", fontdict = {"fontsize": 20})
plt.tight_layout(pad = 0)
plt.show()


# In[20]:


# HAIR DRYER REVIEWS WORDCLOUD VISUALIZATION
HDCommentWords = ""
HDStopwords = list(STOPWORDS) + ["will", "br"]
HairDryer.rename(columns = {"REVIEW BODY": "REVIEWBODY"}, inplace = True)
for val in HairDryer.REVIEWBODY:
    val = str(val)
    tokens = val.split()
    for i in range(len(tokens)):
        tokens[i] = tokens[i].lower()
    HDCommentWords += " ".join(tokens) + " " 
HDWordCloud = WordCloud(width = 800, height = 600, background_color = "white", stopwords = HDStopwords, 
                        min_font_size = 10, max_words = 50, mask = None, colormap = "Greens",
                        random_state = 4, collocations = False).generate(HDCommentWords)                    
HairDryer.rename(columns = {"REVIEWBODY": "REVIEW BODY"}, inplace = True)
plt.figure(figsize = (8, 8), facecolor = None)
plt.imshow(HDWordCloud)
plt.axis("off")
plt.title("HAIR DRYER\n", fontdict = {"fontsize": 20})
plt.tight_layout(pad = 0)
plt.show()


# In[21]:


# MICROWAVE OVEN REVIEWS WORDCLOUD VISUALIZATION
MOCommentWords = ""
MOStopwords = list(STOPWORDS) + ["will", "ge"]
MicrowaveOven.rename(columns = {"REVIEW BODY": "REVIEWBODY"}, inplace = True)
for val in MicrowaveOven.REVIEWBODY:
    val = str(val)
    tokens = val.split()
    for i in range(len(tokens)):
        tokens[i] = tokens[i].lower()
    MOCommentWords += " ".join(tokens) + " " 
MOWordCloud = WordCloud(width = 800, height = 600, background_color = "white", stopwords = MOStopwords, 
                        min_font_size = 10, max_words = 50, mask = None, colormap = "Reds",
                        random_state = 3, collocations = False).generate(MOCommentWords)                    
MicrowaveOven.rename(columns = {"REVIEWBODY": "REVIEW BODY"}, inplace = True)
plt.figure(figsize = (8, 8), facecolor = None)
plt.imshow(MOWordCloud)
plt.axis("off")
plt.title("MICROWAVE OVEN\n", fontdict = {"fontsize": 20})
plt.tight_layout(pad = 0)
plt.show()


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ WORD SETS FREQUENCIES
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# This section involves the process of extracting and counting the most common words from customer reviews associated with different star ratings (1 to 5). For each star rating, the code first filters the dataset to include only entries with the corresponding star rating. Then, it extracts the review bodies from these filtered entries and converts them into lowercase strings. The <strong>Counter</strong> class from the collections module is then utilized to count the occurrences of each word in the review bodies. The resulting word sets are sorted in descending order of frequency and stored in dataframes (<strong>WordSetDataFrame1</strong> to <strong>WordSetDataFrame5</strong>). Each dataframe contains two columns: <strong>"WORDS"</strong> representing the words and <strong>"COUNT"</strong> indicating their respective frequencies. This process provides insights into the most frequently occurring words in customer reviews for each star rating category, aiding in understanding the key aspects influencing customer ratings and sentiments.
#     </div>
# </details>   

# In[22]:


# 1-STAR RATING WORD SET
WordSet1Star = DataSet[DataSet['STAR RATING'] == 1]['REVIEW BODY']
WordSetRating1 = pd.DataFrame(WordSet1Star)
WordSetCounter1 = Counter(" ".join(WordSetRating1["REVIEW BODY"].str.lower()).split()).most_common(900)
WordSetDataFrame1 = pd.DataFrame(WordSetCounter1, columns = ["WORDS", "COUNT"])
WordSetDataFrame1.index = WordSetDataFrame1.index + 1
WordSetDataFrame1


# In[23]:


# 2-STAR RATING WORD SET
WordSet2Star = DataSet[DataSet['STAR RATING'] == 2]['REVIEW BODY']
WordSetRating2 = pd.DataFrame(WordSet2Star)
WordSetCounter2 = Counter(" ".join(WordSetRating2["REVIEW BODY"].str.lower()).split()).most_common(900)
WordSetDataFrame2 = pd.DataFrame(WordSetCounter2, columns = ["WORDS", "COUNT"])
WordSetDataFrame2.index = WordSetDataFrame2.index + 1
WordSetDataFrame2


# In[24]:


# 3-STAR RATING WORD SET
WordSet3Star = DataSet[DataSet['STAR RATING'] == 3]['REVIEW BODY']
WordSetRating3 = pd.DataFrame(WordSet3Star)
WordSetCounter3 = Counter(" ".join(WordSetRating3["REVIEW BODY"].str.lower()).split()).most_common(900)
WordSetDataFrame3 = pd.DataFrame(WordSetCounter3, columns = ["WORDS", "COUNT"])
WordSetDataFrame3.index = WordSetDataFrame3.index + 1
WordSetDataFrame3


# In[25]:


# 4-STAR RATING WORD SET
WordSet4Star = DataSet[DataSet['STAR RATING'] == 4]['REVIEW BODY']
WordSetRating4 = pd.DataFrame(WordSet4Star)
WordSetCounter4 = Counter(" ".join(WordSetRating4["REVIEW BODY"].str.lower()).split()).most_common(900)
WordSetDataFrame4 = pd.DataFrame(WordSetCounter4, columns = ["WORDS", "COUNT"])
WordSetDataFrame4.index = WordSetDataFrame4.index + 1
WordSetDataFrame4


# In[26]:


# 5-STAR RATING WORD SET
WordSet5Star = DataSet[DataSet['STAR RATING'] == 5]['REVIEW BODY']
WordSetRating5 = pd.DataFrame(WordSet5Star)
WordSetCounter5 = Counter(" ".join(WordSetRating5["REVIEW BODY"].str.lower()).split()).most_common(900)
WordSetDataFrame5 = pd.DataFrame(WordSetCounter5, columns = ["WORDS", "COUNT"])
WordSetDataFrame5.index = WordSetDataFrame5.index + 1
WordSetDataFrame5


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ WORLD CLOUD SUMMARY
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# After which, we perform an analysis of word sets derived from customer reviews. We identify the intersection of word sets among all star ratings using the <strong> is_word()</strong>  function to filter out non-English words. This provides us with a set of common words present across all star ratings. Subsequently, we create a summary dataframe named <strong>WordSetSummary</strong>  focusing on specific words of interest. We utilize regular expressions to filter for words reflecting sentiments such as <strong>'enough,' 'easy,' 'cheap,' 'almost,' 'difficult,' 'different,' 'least,' 'expensive,' 'happy,' 'exactly,' 'best,' 'cute,'</strong>  and <strong> 'suck.'</strong> These words are extracted from each star rating's word set dataframe and merged into a single dataframe, facilitating comparison across different star ratings. The resulting dataframe provides insights into the frequency of occurrence of these sentiment-related words across different star ratings, aiding in understanding the prevailing sentiments associated with each rating category.
#     </div>
# </details>   

# In[27]:


# WORD SET INTERSECTIONS
def is_word(word):
    return word.lower() in nltk.corpus.words.words()
Set1 = set(WordSetDataFrame1["WORDS"].values.tolist())
Set2 = set(WordSetDataFrame2["WORDS"].values.tolist())
Set3 = set(WordSetDataFrame3["WORDS"].values.tolist())
Set4 = set(WordSetDataFrame4["WORDS"].values.tolist())
Set5 = set(WordSetDataFrame5["WORDS"].values.tolist())
SetIntersection = list(Set1.intersection(Set2, Set3, Set4, Set5))
SetIntersection = {word for word in SetIntersection if is_word(word)}
print(SetIntersection)


# In[28]:


# WORD SET SUMMARY DATAFRAME
warnings.filterwarnings("ignore")
Words = r"\b(enough|easy|cheap|almost|difficult|different|least|expensive|happy|exactly|best|cute|suck)\b"
WordSet1 = WordSetDataFrame1[WordSetDataFrame1["WORDS"].str.contains(Words)].sort_values("WORDS", ascending = True)
WordSet2 = WordSetDataFrame2[WordSetDataFrame2["WORDS"].str.contains(Words)].sort_values("WORDS", ascending = True)
WordSet3 = WordSetDataFrame3[WordSetDataFrame3["WORDS"].str.contains(Words)].sort_values("WORDS", ascending = True)
WordSet4 = WordSetDataFrame4[WordSetDataFrame4["WORDS"].str.contains(Words)].sort_values("WORDS", ascending = True)
WordSet5 = WordSetDataFrame5[WordSetDataFrame5["WORDS"].str.contains(Words)].sort_values("WORDS", ascending = True)
Merge1 = pd.merge(WordSet1, WordSet2[['WORDS','COUNT']], on='WORDS', how='left', suffixes=('_1', '_2'))
Merge2 = pd.merge(Merge1, WordSet3[['WORDS','COUNT']], on = 'WORDS', how = 'left', suffixes = ('_2', '_3'))
Merge3 = pd.merge(Merge2, WordSet4[['WORDS','COUNT']], on = 'WORDS', how = 'left', suffixes = ('_3', '_4'))
Merge4 = pd.merge(Merge3, WordSet5[['WORDS','COUNT']], on = 'WORDS', how = 'left', suffixes = ('_4', '_5'))
WordSetSummary = Merge4.set_axis(["WORDS", "1-STAR", "2-STAR", "3-STAR", "4-STAR", "5-STAR"], axis = 1)
WordSetSummary["FREQUENCY"] = WordSetSummary[["1-STAR", "2-STAR", "3-STAR", "4-STAR", "5-STAR"]].sum(axis = 1)
WordSetSummary = WordSetSummary.round(0)
WordSetSummary = WordSetSummary[WordSetSummary["WORDS"].str.match(Words, case = False)]
WordSetSummary


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ PRODUCTS HELPFULNESS RATING
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# These code snippets are dedicated to analyze the helpfulness ratings of customer reviews. The codes systematically calculate the helpfulness rating for each star rating within each product category. First, it subsets the dataset based on product categories. Then, it groups the data by star rating and aggregates the helpful votes and total votes for each rating. Using <strong>numpy</strong> arrays, the code computes the ratio of helpful votes to total votes, which represents the percentage of helpfulness for each star rating. Throughout the code, key functions such as <strong>groupby()</strong>, <strong>sum()</strong>, <strong>to_frame()</strong>, and <strong>np.round()</strong> are leveraged to perform data aggregation, computation, and formatting tasks efficiently. This approach enables a robust analysis of customer feedback, aiding the company in understanding the extent to which reviews influence consumer decisions and perceptions of product quality.
#     </div>
# </details>   

# In[29]:


# BABY PACIFIER HELPFULNESS RATING
BPGroup = DataSet[DataSet["PRODUCT CATEGORY"] == "Baby"]
BPHelpfulVotes = BPGroup.groupby(by = "STAR RATING")["HELPFUL VOTES"].sum().to_frame("HELPFUL VOTES")
BPTotalVotes = BPGroup.groupby(by = "STAR RATING")["TOTAL VOTES"].sum().to_frame("TOTAL VOTES")
BPHelpfulVotes["TOTAL VOTES"] = BPTotalVotes["TOTAL VOTES"].tolist()
BPHV = np.array(BPHelpfulVotes["HELPFUL VOTES"].tolist())
BPTV = np.array(BPHelpfulVotes["TOTAL VOTES"].tolist())
Ratio = np.round(BPHV/BPTV*100, decimals = 2)
BPRatio = [f"{i}%" for i in Ratio]
BPHelpfulVotes["RATIO"] = BPRatio
BPHelpfulVotes.T


# In[30]:


# HAIR DRYER HELPFULNESS RATING
HDGroup = DataSet[DataSet["PRODUCT CATEGORY"] == "Beauty"]
HDHelpfulVotes = HDGroup.groupby(by = "STAR RATING")["HELPFUL VOTES"].sum().to_frame("HELPFUL VOTES")
HDTotalVotes = HDGroup.groupby(by = "STAR RATING")["TOTAL VOTES"].sum().to_frame("TOTAL VOTES")
HDHelpfulVotes["TOTAL VOTES"] = HDTotalVotes["TOTAL VOTES"].tolist()
HDHV = np.array(HDHelpfulVotes["HELPFUL VOTES"].tolist())
HDTV = np.array(HDHelpfulVotes["TOTAL VOTES"].tolist())
Ratio = np.round(HDHV/HDTV*100, decimals = 2)
HDRatio = [f"{i}%" for i in Ratio]
HDHelpfulVotes["RATIO"] = HDRatio
HDHelpfulVotes.T


# In[31]:


# MICROWAVE OVEN HELPFULNESS RATING
MOGroup = DataSet[DataSet["PRODUCT CATEGORY"] == "Major Appliances"]
MOHelpfulVotes = MOGroup.groupby(by = "STAR RATING")["HELPFUL VOTES"].sum().to_frame("HELPFUL VOTES")
MOTotalVotes = MOGroup.groupby(by = "STAR RATING")["TOTAL VOTES"].sum().to_frame("TOTAL VOTES")
MOHelpfulVotes["TOTAL VOTES"] = MOTotalVotes["TOTAL VOTES"].tolist()
MOHV = np.array(MOHelpfulVotes["HELPFUL VOTES"].tolist())
MOTV = np.array(MOHelpfulVotes["TOTAL VOTES"].tolist())
Ratio = np.round(MOHV/MOTV*100, decimals = 2)
MORatio = [f"{i}%" for i in Ratio]
MOHelpfulVotes["RATIO"] = MORatio
MOHelpfulVotes.T


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ PRODUCTS SENTIMENT ANALYSIS
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# The following codes utilize the <strong>SentimentIntensityAnalyzer</strong> from the <strong>NLTK</strong> library to assess the sentiment polarity of each review, categorizing them into negative, neutral, and positive sentiments. For each product category, the code iterates through the corresponding dataset, processing each review text. The sentiment scores are then stored in dictionaries, keyed by the customer ID. Subsequently, these sentiment scores are converted into dataframes and merged with the original dataset to retain the context of each review. Throughout the code, essential functions such as <strong>fillna()</strong> for handling missing values, <strong>iterrows()</strong> for iterating through rows efficiently, and <strong>merge()</strong> for combining dataframes based on common columns are utilized. Additionally, <strong>tqdm</strong> is employed to provide a progress bar for the iteration process, enhancing the code's user-friendliness and providing visibility into the analysis progress. Finally, the sentiment analysis results, including the sentiment scores and star ratings, are exported to Excel files for further analysis.
#     </div>
# </details>   

# In[32]:


# BABY PACIFIER SENTIMENT INTENSITY ANALYZER
BabyPacifier["REVIEW BODY"] = BabyPacifier["REVIEW BODY"].fillna("")
BabyPacifierSentiment = {}
for i, row in tqdm(BabyPacifier.iterrows(), total = len(BabyPacifier)):
    Reviews = row["REVIEW BODY"]
    ID = row["CUSTOMER ID"]
    BabyPacifierSentiment[ID] = SentimentIntensityAnalyzer().polarity_scores(Reviews)
BPSentiment = pd.DataFrame(BabyPacifierSentiment).T
BPSentiment = BPSentiment.reset_index().rename(columns = {"index": "CUSTOMER ID"})
BPSentiment = BPSentiment.merge(BabyPacifier, how = "left")
BPSentiment.index = BPSentiment.index + 1
BPSentiment[["neg", "neu", "pos", "STAR RATING"]]


# In[33]:


# HAIR DRYER SENTIMENT INTENSITY ANALYZER
HairDryer["REVIEW BODY"] = HairDryer["REVIEW BODY"].fillna("")
HairDryerSentiment = {}
for i, row in tqdm(HairDryer.iterrows(), total = len(HairDryer)):
    HDReviews = row["REVIEW BODY"]
    HDID = row["CUSTOMER ID"]
    HairDryerSentiment[HDID] = SentimentIntensityAnalyzer().polarity_scores(HDReviews)
HDSentiment = pd.DataFrame(HairDryerSentiment).T
HDSentiment = HDSentiment.reset_index().rename(columns = {"index": "CUSTOMER ID"})
HDSentiment = HDSentiment.merge(HairDryer, how = "left")
HDSentiment.index = HDSentiment.index + 1
HDSentiment[["neg", "neu", "pos", "STAR RATING"]]


# In[34]:


# MICROWAVE OVEN SENTIMENT INTENSITY ANALYZER
MicrowaveOven["REVIEW BODY"] = MicrowaveOven["REVIEW BODY"].fillna("")
MicrowaveOvenSentiment = {}
for i, row in tqdm(MicrowaveOven.iterrows(), total = len(MicrowaveOven)):
    MOReviews = row["REVIEW BODY"]
    MOID = row["CUSTOMER ID"]
    MicrowaveOvenSentiment[MOID] = SentimentIntensityAnalyzer().polarity_scores(MOReviews)
MOSentiment = pd.DataFrame(MicrowaveOvenSentiment).T
MOSentiment = MOSentiment.reset_index().rename(columns = {"index": "CUSTOMER ID"})
MOSentiment = MOSentiment.merge(MicrowaveOven, how = "left")
MOSentiment.index = MOSentiment.index + 1
MOSentiment[["neg", "neu", "pos", "STAR RATING"]]


# In[35]:


# SENTIMENT INTENSITY ANALYZER EXCEL SHEET
BPSentiment[["neg", "neu", "pos", "STAR RATING"]].to_excel("BPSentiment.xlsx")
HDSentiment[["neg", "neu", "pos", "STAR RATING"]].to_excel("HDSentiment.xlsx")
MOSentiment[["neg", "neu", "pos", "STAR RATING"]].to_excel("MOSentiment.xlsx")  


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ RENDERING TIME-SERIES GRAPHS
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# Initially, a time-series dataframe is constructed from the review dates of each product category, and the intersection of dates across all categories is identified. The resulting dataframe is then plotted as a combined time-series visualization, showcasing the trends in product purchases over time. The code utilized <strong>pd.to_datetime()</strong> to convert the <strong>"REVIEW DATE"</strong> column to datetime format for proper plotting, and <strong>DataFrame.plot()</strong> to create the time-series plot. Additionally, <strong>plt.subplots()</strong> is employed to create subplots for individual time-series visualizations, allowing for a more detailed examination of each product category's purchase trends. Furthermore, differencing is performed on the time-series data to compute the changes in product purchases over time, facilitating the identification of any significant fluctuations or trends. We then employ <strong>matplotlib</strong> to generate the time-series graphs, with various customization options such as marker styles, line widths, and colors to enhance visualization clarity.
#     </div>
# </details>   

# In[36]:


# TIME-SERIES DATAFRAME
BPSeries = BabyPacifier["REVIEW DATE"].unique()
HDSeries = HairDryer["REVIEW DATE"].unique()
MOSeries = MicrowaveOven["REVIEW DATE"].unique()
BPSet = set(BPSeries.tolist())
HDSet = set(HDSeries.tolist())
MOSet = set(MOSeries.tolist())
SeriesIntersection = list(HDSet.intersection(BPSet, MOSet))
DateIntersections = pd.DataFrame(SeriesIntersection, columns = ["DATE INTERSECTIONS"])
DateIntersections.sort_values(by = "DATE INTERSECTIONS", ascending = False)
DateIntersections.to_excel("DateIntersections.xlsx")
TimeSeriesDataFrame = pd.read_csv("TimeSeriesAnalysis.csv")
TimeSeriesDataFrame.index = TimeSeriesDataFrame.index + 1
TimeSeriesDataFrame


# In[37]:


# COMBINED TIME-SERIES VISUALIZATION
ColorPalette = ["orange", "purple", "green"]
TimeSeriesDataFrame["REVIEW DATE"] = pd.to_datetime(TimeSeriesDataFrame["REVIEW DATE"])
TimeSeries = TimeSeriesDataFrame.plot("REVIEW DATE", figsize = (14.5, 4), marker = "o", color = ColorPalette, lw = 1, ms = 5)
plt.xlabel("\nREVIEW DATE")
plt.ylabel("PRODUCT PURCHASES")
plt.grid(alpha = 0.3)


# In[38]:


# INDIVIDUAL TIME-SERIES VISUALIZATION
DataFrame = TimeSeriesDataFrame.set_index("REVIEW DATE")
fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize = (14.5, 11), sharex = True)
DataFrame.plot(subplots = True, ax = (ax1, ax2, ax3), marker = 'o', linewidth = 1, markersize = 5, color = ColorPalette)
ax1.grid(alpha = 0.3)
ax2.grid(alpha = 0.3)
ax3.grid(alpha = 0.3)
ax1.legend(loc = "upper left")
ax2.legend(loc = "upper left")
ax3.legend(loc = "upper left")
plt.xlabel("\nREVIEW DATE")
ax2.set_ylabel("PRODUCT PURCHASES\n")


# In[39]:


# TIME-SERIES DIFFERENCING
DataFrame["BABY PACIFIER DIFFERENCE"] = DataFrame["BABY PACIFIER"].diff()
DataFrame["HAIR DRYER DIFFERENCE"] = DataFrame["HAIR DRYER"].diff()
DataFrame["MICROWAVE OVEN DIFFERENCE"] = DataFrame["MICROWAVE OVEN"].diff()
Frame = ["BABY PACIFIER DIFFERENCE", "HAIR DRYER DIFFERENCE", "MICROWAVE OVEN DIFFERENCE"]
fig2, (ax11, ax22, ax33) = plt.subplots(3, 1, figsize = (14.5, 11), sharex = True)
DataFrame[Frame].plot(subplots = True, ax = (ax11, ax22, ax33), marker = 'o', linewidth = 1, markersize = 5,
                      color = ColorPalette)
ax11.grid(alpha = 0.3)
ax22.grid(alpha = 0.3)
ax33.grid(alpha = 0.3)
ax11.legend(loc = "upper left")
ax22.legend(loc = "upper left")
ax33.legend(loc = "upper left")
plt.xlabel("\nREVIEW DATE")


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ PRODUCTS CORRELOGRAM ANALYSIS
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# The autocorrelation functions (ACF) and partial autocorrelation functions (PACF) are essential tools for understanding the temporal dependency structure within time-series data. The codes first create separate figures and subplots for each product category, setting the layout and <strong>sharey</strong> parameter to ensure consistent y-axis scaling across plots. Within each subplot, the autocorrelation and partial autocorrelation functions are computed and plotted using the <strong>plot_acf()</strong> and <strong>plot_pacf()</strong> functions, respectively. These functions accept the differenced time-series data as input and visualize the autocorrelation and partial autocorrelation coefficients at various lags. We then utilized <strong>plot_acf()</strong> and <strong>plot_pacf()</strong> from the <strong>statsmodels</strong> library, which compute and plot autocorrelation and partial autocorrelation functions, respectively. Additionally, the <strong>grid()</strong> function is employed to add grid lines to the plots, enhancing readability. The <strong>color</strong> parameter is utilized to customize the color of the plots, providing visual distinction between the different product categories.
#     </div>
# </details>   

# In[40]:


# BABY PACIFIER CORRELOGRAM ANALYSIS
figBP, BPdimensions = plt.subplots(figsize = (10, 3), sharey = True)
pyplot.grid(True, alpha = 0.3)
plot_acf(DataFrame["BABY PACIFIER DIFFERENCE"].dropna(), color = "fuchsia", ax = BPdimensions,
         vlines_kwargs = {"colors": "fuchsia"})
plt.title("AUTOCORRELATION FUNCTION (BABY PACIFIER)\n", fontsize = 15)
for item in BPdimensions.collections:
    if type(item) == PolyCollection:
        item.set_facecolor("fuchsia")
figBP, BPdimensions = plt.subplots(figsize = (10, 3),  sharey = True)
pyplot.grid(True, alpha = 0.3)
plot_pacf(DataFrame["BABY PACIFIER DIFFERENCE"].dropna(), color = "fuchsia", ax = BPdimensions,
          vlines_kwargs = {"colors": "fuchsia"})
plt.title("PARTIAL AUTOCORRELATION FUNCTION (BABY PACIFIER)\n", fontsize = 15)
for item in BPdimensions.collections:
    if type(item) == PolyCollection:
        item.set_facecolor("fuchsia")


# In[41]:


# HAIR DRYER CORRELOGRAM ANALYSIS
figHD, HDdimensions = plt.subplots(figsize = (10, 3), sharey = True)
pyplot.grid(True, alpha = 0.3)
plot_acf(DataFrame["HAIR DRYER DIFFERENCE"].dropna(), color = "blue", ax = HDdimensions,
         vlines_kwargs = {"colors": "blue"})
plt.title("AUTOCORRELATION FUNCTION (HAIR DRYER)\n", fontsize = 15)
for item in HDdimensions.collections:
    if type(item) == PolyCollection:
        item.set_facecolor("blue")
figHD, HDdimensions = plt.subplots(figsize = (10, 3),  sharey = True)
pyplot.grid(True, alpha = 0.3)
plot_pacf(DataFrame["HAIR DRYER DIFFERENCE"].dropna(), color = "blue", ax = HDdimensions,
          vlines_kwargs = {"colors": "blue"})
plt.title("PARTIAL AUTOCORRELATION FUNCTION (HAIR DRYER)\n", fontsize = 15)
for item in HDdimensions.collections:
    if type(item) == PolyCollection:
        item.set_facecolor("blue")


# In[42]:


# MICROWAVE OVEN CORRELOGRAM ANALYSIS
figMO, MOdimensions = plt.subplots(figsize = (10, 3), sharey = True)
pyplot.grid(True, alpha = 0.3)
plot_acf(DataFrame["MICROWAVE OVEN DIFFERENCE"].dropna(), color = "red", ax = MOdimensions,
         vlines_kwargs = {"colors": "red"})
plt.title("AUTOCORRELATION FUNCTION (MICROWAVE OVEN)\n", fontsize = 15)
for item in MOdimensions.collections:
    if type(item) == PolyCollection:
        item.set_facecolor("red")
figMO, MOdimensions = plt.subplots(figsize = (10, 3),  sharey = True)
pyplot.grid(True, alpha = 0.3)
plot_pacf(DataFrame["MICROWAVE OVEN DIFFERENCE"].dropna(), color = "red", ax = MOdimensions,
          vlines_kwargs = {"colors": "red"})
plt.title("PARTIAL AUTOCORRELATION FUNCTION (MICROWAVE OVEN)\n", fontsize = 15)
for item in MOdimensions.collections:
    if type(item) == PolyCollection:
        item.set_facecolor("red")


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ MODEL FITTING CALCULATIONS
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# The code now performs model fitting for each product category, provided by the <strong>pmdarima</strong> library. This automatically selects the optimal parameters for an ARIMA model based on the time-series data provided. The <strong>trace</strong> parameter is set to <strong>True</strong> to display diagnostic information during the model fitting process, while <strong>suppress_warnings</strong> is set to <strong>True</strong> to suppress any non-critical warnings. The <strong>auto_arima</strong> function conducts a stepwise search to identify the best ARIMA model configuration based on criteria such as <strong>AIC</strong> (<strong>Akaike Information Criterion</strong>) or <strong>BIC</strong> (<strong>Bayesian Information Criterion</strong>). This search involves iteratively fitting different ARIMA models with varying parameters and selecting the model with the lowest information criterion value, indicating the best balance between model complexity and goodness of fit. After fitting the ARIMA model, the code proceeds to split the time-series data into training and test sets using <strong>iloc</strong> indexing. The training data comprises all observations except the last 10 data points, while the test data consists of the last 10 data points. This split allows for the evaluation of the model's performance on unseen data, enabling assessment of its predictive accuracy.
#     </div>
# </details>   

# In[43]:


# BABY PACIFIER MODEL FITTING
StepwiseFit = auto_arima(TimeSeriesDataFrame["BABY PACIFIER"], trace = True, suppress_warnings = True)


# In[44]:


# HAIR DRYER MODEL FITTING
StepwiseFit = auto_arima(TimeSeriesDataFrame["HAIR DRYER"], trace = True, suppress_warnings = True)


# In[45]:


# MICROWAVE OVEN MODEL FITTING
StepwiseFit = auto_arima(TimeSeriesDataFrame["MICROWAVE OVEN"], trace = True, suppress_warnings = True)


# In[46]:


# TRAINING THE MODEL FIT
TrainData = TimeSeriesDataFrame.iloc[:-10]
TestData = TimeSeriesDataFrame.iloc[-10:]
print("TRAIN DATA:", TrainData.shape, "\n", "TEST DATA:", TestData.shape)


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ PRODUCTS TIME-SERIES ANALYSIS
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# In the section, the code performs <strong>ARIMA</strong> (<strong>AutoRegressive Integrated Moving Average</strong>) modeling for each product category. ARIMA models are commonly used for time-series forecasting by incorporating <strong>autoregressive</strong> (<strong>AR</strong>), <strong>differencing</strong> (<strong>I</strong>), and <strong>moving average</strong> (<strong>MA</strong>) components. First, ARIMA models are instantiated using the <strong>ARIMA</strong> class from the <strong>statsmodels</strong> library, specifying the order parameter (p, d, q). Here, <strong>'p'</strong> represents the autoregressive order, <strong>'d'</strong> denotes the differencing order, and <strong>'q'</strong> indicates the moving average order. These parameters are selected based on the characteristics of the time series data and the results obtained from earlier model fitting processes. Next, the ARIMA models are fitted to the training data using the <strong>fit</strong> method, where the <strong>TrainData</strong> dataframe contains the historical time-series data for each product category. The fitted models are stored in respective variables: <strong>BPARIMAmode</strong>l for Baby Pacifier, <strong>HDARIMAmodel</strong> for Hair Dryer, and <strong>MOARIMAmodel</strong> for Microwave Oven. Once fitted, the code generates a summary of each ARIMA model using the <strong>summary</strong> method. This summary provides detailed information about the fitted model, including coefficient estimates, standard errors, t-statistics, p-values, and diagnostic statistics such as AIC (Akaike Information Criterion) and BIC (Bayesian Information Criterion). These statistics are essential for evaluating the model's goodness of fit and determining whether the chosen model adequately captures the underlying patterns and dynamics of the time-series data.
#     </div>
# </details>   

# In[47]:


# BABY PACIFIER ARIMA MODEL
BPARIMAmodel = ARIMA(TrainData["BABY PACIFIER"], order = (2,1,1))
BPARIMAmodel = BPARIMAmodel.fit()
BPARIMAmodel.summary()


# In[48]:


# HAIR DRYER ARIMA MODEL
HDARIMAmodel = ARIMA(TrainData["HAIR DRYER"], order = (0,1,1))
HDARIMAmodel = HDARIMAmodel.fit()
HDARIMAmodel.summary()


# In[49]:


# MICROWAVE OVEN ARIMA MODEL
MOARIMAmodel = ARIMA(TrainData["MICROWAVE OVEN"], order = (0,1,1))
MOARIMAmodel = MOARIMAmodel.fit()
MOARIMAmodel.summary()


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ MODELS ACCURACY TEST
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# And then we evaluate the accuracy of the ARIMA models previously fitted for each product category. The accuracy is assessed using the <strong>Mean Absolute Percentage Error</strong> (<strong>MAPE</strong>), which measures the percentage difference between the predicted values and the actual values of the time series data. First, predictions are made for the test data using each fitted ARIMA model. The <strong>predict</strong> method is applied to generate forecasts for the time period beyond the training data, covering the test data range. The start and end parameters specify the indices corresponding to the test data range. Once predictions are obtained, the MAPE is calculated by comparing the predicted values to the actual values from the test data. The <strong>mean_absolute_percentage_error</strong> function is a custom computes the MAPE between the predicted and actual values. Finally, the MAPE values are formatted and printed to the console, providing insights into the accuracy of the ARIMA models for each product category.
#     </div>
# </details>   

# In[50]:


# BABY PACIFIER MODEL ACCURACY TEST
BPPredictionAccuracy = BPARIMAmodel.predict(start = len(TrainData) + 1, end = len(TrainData) + len(TestData))
BPMAPEvalue = mean_absolute_percentage_error(TestData["BABY PACIFIER"], BPPredictionAccuracy)
BPMAPE = "{:.2%}".format(BPMAPEvalue*0.1)
print("MEAN ABSOLUTE PERCENTAGE ERROR (BABY PACIFIER):", BPMAPE)


# In[51]:


# HAIR DRYER MODEL ACCURACY TEST
HDPredictionAccuracy = HDARIMAmodel.predict(start = len(TrainData) + 1, end = len(TrainData) + len(TestData))
HDMAPEvalue = mean_absolute_percentage_error(TestData["HAIR DRYER"], HDPredictionAccuracy)
HDMAPE = "{:.2%}".format(HDMAPEvalue*0.1)
print("MEAN ABSOLUTE PERCENTAGE ERROR (HAIR DRYER):", HDMAPE)


# In[52]:


# MICROWAVE OVEN MODEL ACCURACY TEST
MOPredictionAccuracy = MOARIMAmodel.predict(start = len(TrainData) + 1, end = len(TrainData) + len(TestData))
MOMAPEvalue = mean_absolute_percentage_error(TestData["HAIR DRYER"], MOPredictionAccuracy)
MOMAPE = "{:.2%}".format(MOMAPEvalue*0.1)
print("MEAN ABSOLUTE PERCENTAGE ERROR (MICROWAVE OVEN):", MOMAPE)


# <details>
#     <summary> 
#         <strong style = "cursor: pointer; background-color: rgba(0, 0, 0, 0.2); color: #000000; font-family: Franklin Gothic Heavy; padding: 8px; border-radius: 5px; display: inline-block;"> 
#             🖥️ RENDERING ARIMA FORECAST GRAPHS
#         </strong> 
#         <br>
#     </summary>
#     <div style = "padding: 8px; padding-left: 0px"> 
# The analyses end with this section, where the code generates visualizations to illustrate the forecasted product purchases based on the ARIMA models previously fitted for each product category. The ARIMA model's <strong>predict</strong> method is employed to generate future forecasts beyond the available data. The start and end parameters specify the range of indices for which forecasts are generated, extending beyond the existing time series data. These forecasts represent the predicted values for product purchases over a future time period. Subsequently, the <strong>matplotlib</strong> library is utilized to create line plots visualizing both the actual product purchases and the forecasted values. The <strong>actual</strong> values from the time series data are plotted in a lighter shade to provide context, while the <strong>forecasted</strong> values are plotted with a solid line to distinguish them. Each plot includes labels and legends to identify the actual and forecasted data series, enhancing interpretability. By rendering these forecast graphs, the SUnshine company can visually assess the projected trends for each product category and understand the potential demand for Baby Pacifiers, Hair Dryers, and Microwave Ovens in the future. These visualizations play a crucial role in strategic planning, inventory management, and decision-making processes.
#     </div>
# </details>   

# In[53]:


# BABY PACIFIER ARIMA FORECAST VISUALIZATION
BPTotalForecast = BPARIMAmodel.predict(start = len(TimeSeriesDataFrame) - 765, end = len(TimeSeriesDataFrame) + 10)
plt.plot(TimeSeriesDataFrame["BABY PACIFIER"], color = "crimson", label = "ACTUAL BABY PACIFIER PURCHASES", alpha = 0.5)
BPFuturePrediction = BPTotalForecast.plot(figsize = (14.5, 2.5), color = "crimson", label = "FORECASTED BABY PACIFIER PURCHASES")
plt.legend(loc = "upper left")
BPFuturePrediction.set_xlabel("\nDATE INDEX")
BPFuturePrediction.set_ylabel("PRODUCT PURCHASES\n")
BPFuturePrediction.grid(True, alpha = 0.3)


# In[54]:


# HAIR DRYER ARIMA FORECAST VISUALIZATION
HDTotalForecast = HDARIMAmodel.predict(start = len(TimeSeriesDataFrame) - 765, end = len(TimeSeriesDataFrame) + 10)
plt.plot(TimeSeriesDataFrame["HAIR DRYER"], color = "teal", label = "ACTUAL HAIR DRYER PURCHASES", alpha = 0.5)
HDFuturePrediction = HDTotalForecast.plot(figsize = (14.5, 2.5), color = "teal", label = "FORECASTED HAIR DRYER PURCHASES")
plt.legend(loc = "upper left")
HDFuturePrediction.set_xlabel("\nDATE INDEX")
HDFuturePrediction.set_ylabel("PRODUCT PURCHASES\n")
HDFuturePrediction.grid(True, alpha = 0.3)


# In[55]:


# MICROWAVE OVEN ARIMA FORECAST VISUALIZATION
MOTotalForecast = MOARIMAmodel.predict(start = len(TimeSeriesDataFrame) - 765, end = len(TimeSeriesDataFrame) + 10)
plt.plot(TimeSeriesDataFrame["MICROWAVE OVEN"], color = "darkorchid", label = "ACTUAL MICROWAVE OVEN PURCHASES", alpha = 0.5)
MOFuturePrediction = MOTotalForecast.plot(figsize = (14.5, 2.5), color = "darkorchid", label = "FORECASTED MICROWAVE OVEN PURCHASES")
plt.legend(loc = "upper left")
MOFuturePrediction.set_xlabel("\nDATE INDEX")
MOFuturePrediction.set_ylabel("PRODUCT PURCHASES\n")
MOFuturePrediction.grid(True, alpha = 0.3)


# <hr style = "border: none; border-top: 5px solid #000000; margin: 2px 0;">
# <hr style = "border: none; border-top: 10px solid #000000; margin: 0px 0;">
